name: Terraform Plan/apply
on:
  workflow_call:
    inputs:
      repo_name:
        required: true
        type: string
    secrets:
      GITHUB_TOKEN:
        required: true
      ALL_SECRETS:
        required: true
      BACKEND_BUCKET:
        required: true
      BACKEND_ACCESS_KEY:
        required: true
      BACKEND_SECRET_KEY:
        required: true
      REPO_ACCESS_TOKEN:
        required: true
env:
  GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
  EQUAL_ESCAPE: '_EQUAL_'
  BREAK_LINE: '_BREAK_LINE_'

jobs:
  plan:
    runs-on: ubuntu-latest
    name: Plan/apply terraform
    steps:
      - name: Git checkout
        uses: nschloe/action-cached-lfs-checkout@v1

      - name: Get env name
        shell: bash
        run: echo "##[set-output name=env_name;]$(echo ${GITHUB_BASE_REF:-$GITHUB_REF_NAME} | grep -o '^[^/]*' | tr a-z A-Z)"
        id: extract_env_name

      - name: Create .env and .env.output.envs
        uses: shine1594/secrets-to-env-action@v1.5.2
        with:
          secrets: ${{ secrets.ALL_SECRETS }}
          secrets_env: all
          # Get all secrets as .env
          prefix_prod: _${{ steps.extract_env_name.outputs.env_name }}_
          file_name_prod: terraform/.env
          # Get all TF outputs secrets as .env (env=list of outputs, one per project, per env)
          prefix_dev: _${{ steps.extract_env_name.outputs.env_name }}_TF_OUTPUT_
          file_name_dev: terraform/.env.output.envs

      - name: Load .env
        shell: bash
        run: |
          sed -i -e '$a\' terraform/.env.output.envs
          # Inject output envs from each output secret (one per project) (for this env)
          for i in $(cat terraform/.env.output.envs)
          do
            value=${i#*=}
            value=$(echo "$value" | sed 's,${{ env.EQUAL_ESCAPE }},=,g')
            value=$(echo "$value" | sed 's,${{ env.BREAK_LINE }},\n,g')
            echo "\nval: $value"
            echo "$value" >> $GITHUB_ENV
          done

          # Inject all secrets as envs (for this env)
          (cat terraform/.env) >> $GITHUB_ENV

      - name: To deploy
        shell: bash
        run: |
          echo "##[set-output name=has_envs;]$([ -s terraform/.env ] && echo true)"
        id: to_deploy

      - name: terraform plan
        uses: dflook/terraform-plan@v1.22.2
        if: github.event_name == 'pull_request' && steps.to_deploy.outputs.has_envs == 'true'
        with:
          path: terraform
          backend_config: |
            bucket=${{ env.BACKEND_BUCKET }}
            access_key=${{ env.BACKEND_ACCESS_KEY }}
            secret_key=${{ env.BACKEND_SECRET_KEY }}

      - name: terraform apply
        uses: dflook/terraform-apply@v1.22.2
        if: github.event_name != 'pull_request' && steps.to_deploy.outputs.has_envs == 'true'
        with:
          path: terraform
          backend_config: |
            bucket=${{ secrets.BACKEND_BUCKET }}
            access_key=${{ secrets.BACKEND_ACCESS_KEY }}
            secret_key=${{ secrets.BACKEND_SECRET_KEY }}

      - name: Get outputs
        uses: dflook/terraform-output@v1
        if: github.event_name != 'pull_request' && steps.to_deploy.outputs.has_envs == 'true'
        id: tf_outputs
        with:
          path: terraform
      - name: Prepare output as .env
        if: github.event_name != 'pull_request' && steps.to_deploy.outputs.has_envs == 'true'
        run: |
          # Escape equal sign
          OUTPUT_ENVS=$(echo "${{ toJson(steps.tf_outputs.outputs) }}" | jq -r "to_entries|map(\"TF_VAR_\(.key)${{ env.EQUAL_ESCAPE }}\(.value|tostring)\")|.[]")
          # Remove \n
          OUTPUT_ENVS="${OUTPUT_ENVS//$'\n'/${{ env.BREAK_LINE }}}"
          OUTPUT_ENVS="${OUTPUT_ENVS//$'\r'}"
          echo "##[set-output name=envs;]$OUTPUT_ENVS"
        shell: bash
        id: output_dot_env

      - name: Save output as secret
        uses: hmanzur/actions-set-secret@v2.0.0
        if: github.event_name != 'pull_request' && steps.to_deploy.outputs.has_envs == 'true'
        with:
          name: '_${{ steps.extract_env_name.outputs.env_name }}_TF_OUTPUT_${{ env.repo_name }}'
          value: '${{ steps.output_dot_env.outputs.envs }}'
          token: ${{ secrets.REPO_ACCESS_TOKEN }}